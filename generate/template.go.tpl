// generated by dexp.io DO NOT EDIT
package {{.package}}

import (
	{{range .packages}}
		"{{.}}"
	{{end}}
)


{{ range .entities}}

// {{.entity_name}}

type {{ .entity_title }} struct {
	ID        int64     `json:"id"`
	Type      string    `json:"type"`
	AuthorID  int64     `json:"author_id"`
	LastUpdatedBy int64 `json:"last_updated_by"`
	Status    int8      `json:"status"`
	Deleted   bool      `json:"deleted"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	{{range .fields}}
	{{.Title}} {{.Type}} `json:"{{.Name}}"`
	{{end}}

}


func ({{.entity_short}} *{{.entity_title}}) IsEntity() {}



func ({{.entity_short}} *{{.entity_title}}) ToString() string {

	data, _ := json.Marshal({{.entity_short}})
	return string(data)
}

type {{.entity_title}}FindQuery struct {
	_where   []string
	_orderBy []string
	_args    []interface{}
	_limit   int
	_offset  int
}

func (q *{{.entity_title}}FindQuery) Where(condition string, args ...interface{}) *{{.entity_title}}FindQuery {
	q._where = append(q._where, condition)

	if len(args) > 0 {
		for _, arg := range args {
			q._args = append(q._args, arg)
		}
	}
	return q
}

func (q *{{.entity_title}}FindQuery) OrderBy(field string, value string) *{{.entity_title}}FindQuery {

	value = strings.ToUpper(value)
	if value != "" && (value == "DESC" || value == "ASC") {
		q._orderBy = append(q._orderBy, field+" "+value)
	} else {
		q._orderBy = append(q._orderBy, field)
	}

	return q
}

func (q *{{.entity_title}}FindQuery) Range(limit, offset int) *{{.entity_title}}FindQuery {

	q._limit = limit
	q._offset = offset

	return q
}

func (q *{{.entity_title}}FindQuery) Execute() ([]*{{.entity_title}}, error) {

	s := "SELECT entity.*, {{.select_fields}} FROM {{.entity_table}} AS {{.entity_short}} INNER JOIN `entity` ON {{.entity_short}}.entity_id = entity.id"

	if len(q._where) > 0 {
		s += " WHERE " + strings.Join(q._where, " ")
	}

	if len(q._orderBy) > 0 {
		s += " ORDER BY " + strings.Join(q._orderBy, ", ")
	}
	if q._limit > 0 {
		s += " LIMIT " + strconv.Itoa(q._limit) + " OFFSET " + strconv.Itoa(q._offset)
	}

	rows, err := DB.Query(s, q._args...)



	if err != nil {
		return nil, err
	}

	defer rows.Close()


	var res []*{{.entity_title}}

	for rows.Next() {
		var {{.entity_short}} {{.entity_title}}

		if rows.Scan(&{{.entity_short}}.ID, &{{.entity_short}}.Type, &{{.entity_short}}.AuthorID, &{{.entity_short}}.Status, &{{.entity_short}}.CreatedAt, &{{.entity_short}}.UpdatedAt, {{.scan_fields}}) == nil {
			res = append(res, &{{.entity_short}})
		}
	}

	return res, nil

}

func Find{{.entity_title}}s() *{{.entity_title}}FindQuery {
	return &{{.entity_title}}FindQuery{}
}


func ({{.entity_short}} *{{.entity_title}}) Get(ID int64) error {
	if ID == 0 {
		return errors.New("ID is required")
	}
	err := DB.GetEntityCache(ID, {{.entity_short}})
	if err == nil {
		return nil
	}

	{{.entity_short}}.ID = ID
	row := DB.Select("entity", "e").Join("{{.entity_table}}", "{{.entity_short}}", "{{.entity_short}}.entity_id = e.id").Fields("{{.entity_short}}", []string{
	{{range .fields}}
		"{{.Name}}",
		{{end}}
}).Condition("e.id", {{.entity_short}}.ID, "=").FetchOne()
	err = row.Scan(&{{.entity_short}}.ID, &{{.entity_short}}.Type, &{{.entity_short}}.AuthorID, &{{.entity_short}}.Status, &{{.entity_short}}.CreatedAt, &{{.entity_short}}.UpdatedAt, {{.scan_fields}})
	if err == nil {
		DB.SetEntityCache(ID, {{.entity_short}})
	}
	return err
}


func ({{.entity_short}} * {{.entity_title}}) Insert() error {

	tx, err := DB.Begin()
	if err != nil {
		return err
	}

	{{.entity_short}}.Type = "{{.entity_name}}"
	{{.entity_short}}.LastUpdatedBy = {{.entity_short}}.AuthorID

	res, err := tx.Exec("INSERT INTO `entity` (`type`, `author_id`, `status`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?, ?)",
		{{.entity_short}}.Type, {{.entity_short}}.AuthorID, {{.entity_short}}.Status, {{.entity_short}}.CreatedAt, {{.entity_short}}.UpdatedAt)

	if err != nil {

		tx.Rollback()
		return err
	}

	id, err := res.LastInsertId()

	if err != nil {
		_ = tx.Rollback()
		return err
	}

	{{.entity_short}}.ID = id

	query := "INSERT INTO `{{.entity_table}}` (entity_id, {{.insert_fields}}) VALUES (?, {{.insert_params}})"

	_, err = tx.Exec(query, {{.entity_short}}.ID, {{.insert_values}})

	if err != nil {
		_ = tx.Rollback()
		return err
	}

	err = tx.Commit()

	if err != nil{
		return err
	}

	_ = DB.SetEntityCache(id, {{.entity_short}})

	activity := &Activity{
		UserID:     {{.entity_short}}.AuthorID,
		EntityID:   {{.entity_short}}.ID,
		EntityType: {{.entity_short}}.Type,
		Action:     "created",
		Payload:    "",
	}
	_ = activity.Create()


	
	if {{.entity_short}}.Type != "permission" && {{.entity_short}}.AuthorID > 0 {

		perm := &Permission{
			AuthorID:        {{.entity_short}}.AuthorID,
			GrantUserId:     {{.entity_short}}.AuthorID,
			GrantEntityId:   {{.entity_short}}.ID,
			GrantEntityType: {{.entity_short}}.Type,
			CanView: 		 true,
			CanInsert:       true,
			CanUpdate:       true,
			CanDelete:       true,
		}
		_ = perm.Insert()
	}



	return nil

}



func ({{.entity_short}} *{{.entity_title}}) Update() error {

	tx, err := DB.Begin()

	if err != nil {
		return err
	}

	{{.entity_short}}.UpdatedAt = time.Now()

	_, err = tx.Exec("UPDATE entity SET updated_at = ? WHERE id = ?", {{.entity_short}}.UpdatedAt, {{.entity_short}}.ID)

	if err != nil {

		_ = tx.Rollback()

		return err
	}

	res, err := tx.Exec("UPDATE {{.entity_table}} SET {{.update_fields}} WHERE entity_id = ?", {{.insert_values}}, {{.entity_short}}.ID)
	if err != nil {
		tx.Rollback()

		return err
	}


	err =  tx.Commit()

	if err != nil {
		return err
	}

	effectIds , _ := res.LastInsertId()

	if effectIds > 0{
			activity := &Activity{
			UserID:     {{.entity_short}}.LastUpdatedBy,
			EntityID:   {{.entity_short}}.ID,
			EntityType: {{.entity_short}}.Type,
			Action:     "updated",
			Payload:    "",
		}
		_ = activity.Create()
		DB.SetEntityCache({{.entity_short}}.ID, {{.entity_short}})
	}


	return nil

}



func ({{.entity_short}} *{{.entity_title}}) Delete() error {

	{{.entity_short}}.Deleted = true
	res, err := DB.Exec("UPDATE `entity` SET deleted = 1 WHERE id = ?", {{.entity_short}}.ID)



	if err != nil{
		return nil
	}

	effectIds , _ := res.LastInsertId()

	if effectIds > 0{
		if effectIds > 0{
			activity := &Activity{
                UserID:     {{.entity_short}}.LastUpdatedBy,
				EntityID:   {{.entity_short}}.ID,
				EntityType: {{.entity_short}}.Type,
				Action:     "deleted",
				Payload:    "",
			}
			_ = activity.Create()
			DB.SetEntityCache({{.entity_short}}.ID, {{.entity_short}})
		}
	}

	return err
}


func ({{.entity_short}} *{{.entity_title}}) AddSubscriber(userID int64) error {

	_, err := DB.Insert("entity_has_subscriber").Fields(map[string]interface{}{
		"entity_id": {{.entity_short}}.ID,
		"user_id":   userID,
	}).Execute()

	return err
}

// end {{.entity_name}}
{{end}}